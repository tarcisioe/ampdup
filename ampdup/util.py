'''Utility module.'''

import sys

from enum import Enum, EnumMeta
from functools import lru_cache
from typing import Any, List, Sequence


if sys.version_info < (3, 7):
    from aiocontext import async_contextmanager as asynccontextmanager
else:
    from contextlib import asynccontextmanager  # noqa # pylint: disable=no-name-in-module


__all__ = [
    'asynccontextmanager',
]


class NoCommonTypeError(Exception):
    '''Happens when values in an Enum are not of the same type.'''
    pass


class EmptyEnumError(Exception):
    '''Happens when an enum has no value.'''
    pass


@lru_cache()
def underlying_type(enum_type: EnumMeta) -> type:
    '''Get the underlying type of an enum.

    Returns:
        The type of every value in the enum if it is the same.

    Raises:
        NoCommonTypeError: If the values in the enum are not of the same type.
        EmptyEnumError: If the enum has no value.
    '''
    try:
        first: Any = next(iter(enum_type))
    except StopIteration:
        raise EmptyEnumError('No value in enum.')

    t = type(first.value)

    if any(not isinstance(v.value, t) for v in enum_type):  # type: ignore
        raise NoCommonTypeError('No common type in enum.')

    return t


def is_namedtuple(cls: type) -> bool:
    '''Checks if a type inherits typing.NamedTuple.

    Checking inspects the type and looks for the `_field_types`
    attribute.

    Args:
        cls: Type to inspect.

    Returns:
        Whether or not the type was generated by NamedTuple.
    '''
    return hasattr(cls, '_field_types')


def from_list(list_type, v):
    '''Make a list of typed objects from a JSON-like list, based on type hints.

    Args:
        list_type: A `List[T]`-like type to instantiate .
        v: A JSON-like list.

    Returns:
        An object of type `list_type`.
    '''
    inner_type, = list_type.__args__
    return [from_json_like(inner_type, value) for value in v]


def from_dict(cls, d):
    '''Make an object from a dict, recursively, based on type hints.

    Args:
        cls: The type to instantiate.
        d: a dict of property names to values.

    Returns:
        An object of type `cls`.
    '''
    # pylint:disable=protected-access
    if hasattr(cls, '_renames'):
        for k in d:
            if k in cls._renames:
                d[cls._renames[k]] = d.pop(k)
    return cls(**{i: from_json_like(cls._field_types[i], v)
                  for i, v in d.items()})


def from_json_like(cls, j):
    '''Make an object from a JSON-like value, recursively, based on type hints.

    Args:
        cls: The type to instantiate.
        j: the JSON-like object.

    Returns:
        An object of type `cls`.
    '''
    if is_namedtuple(cls):
        return from_dict(cls, j)
    if issubclass(cls, List):
        return from_list(cls, j)
    if issubclass(cls, Enum):
        return cls(underlying_type(cls)(j))
    if any(issubclass(cls, t) for t in (int, float)):
        return cls(j)
    return j


def has_any_prefix(s: str, prefixes: Sequence[str]) -> bool:
    '''Checks if a string has any of the provided prefixes.

    Args:
        s: The string to check.
        prefixes: A sequence of prefixes to check.

    Returns:
        Whether the string matches any of the prefixes.
    '''
    return any(s.startswith(prefix) for prefix in prefixes)
